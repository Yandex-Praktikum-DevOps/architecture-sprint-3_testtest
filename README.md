# Проектная работа 3 спринта

## Задание 1: Анализ и проектирование

### Подзадание 1.1: Анализ и планирование

#### 1. Функциональность текущего решения

Приложение должно реализовывать следующие функции:
- Управление отоплением:
  - Пользователи могут удалённо включать/выключать отопление в своих домах (интерфейс взаимодействия с устройствами не реализован).
  - Пользователи могут устанавливать желаемую температуру (интерфейс взаимодействия с устройствами не реализован).
  - Система автоматически поддерживает заданную температуру, регулируя подачу тепла (функциональность не реализована).
- Мониторинг температуры:
  - Система получает данные о температуре с датчиков, установленных в домах (интерфейс взаимодействия с датчиками не реализован).
  - Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс (на самом деле пользователи получают предустановленное значение температуры из БД, т.к. интерфейс взаимодействия с датчиками не реализован).

#### 2. Архитектура текущего решения

- Язык программирования: Java
- База данных: PostgreSQL
- Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
- Взаимодействие: Синхронное, запросы обрабатываются последовательно.
- Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
- Развертывание: Требует остановки всего приложения.

#### 3. Домены и границы контекстов для текущего решения компании

Домен: **Управление отоплением** (отвечает за функции, связанные с управлением устройствами отопления в доме и мониторингом состояния системы отопления)

* Поддомен: **Управление отопительными устройствами** (смысловое ядро)

  * Контекст: **Управление устройствами** (обработка команд пользователя, включение/выключение отопления, установка целевой температуры)
    - сущности: устройства (отопительные системы);
объекты-значения: состояние устройства, текущая температура, целевая температура;
    - агрегаты: устройства (отопительные системы);
    - репозитории: репозиторий устройств;
    - сервисы: сервис управления устройствами.

    Задание не уточняет способ взаимодействия с устройством, описывая лишь общее ограничение: "Всё управление идёт от сервера к датчику. Данные о температуре также получаются через запрос от сервера к датчику." Поэтому здесь и далее аспект взаимодействия с устройством описывается исключительно уникальным идентификатором (id) устройства.

* Поддомен: **Телеметрия** (служебный поддомен)

  * Контекст: **Сбор телеметрии** (сбор данных с датчиков отопительных систем)
    - сущности: задачи по сбору телеметрии;
    - объекты-значения: устройство (device_id), активность, период опроса;
    - агрегаты: задачи по сбору телеметрии;
    - репозитории: репозиторий задач;
    - сервисы: сервис сбора телеметрии.

    Функционал для данного контекста не реализован, но потребность в нём подразумевается описанием бизнес-логики: "Система получает данные о температуре с датчиков, установленных в домах.", "Всё управление идёт от сервера к датчику. Данные о температуре также получаются через запрос от сервера к датчику.".

  * Контекст: **Управление телеметрией** (хранение и предоставление телеметрических данных пользователям)
    - сущности: телеметрия;
    - объекты-значения: устройство-источник, состояние устройства, текущая температура, время последнего обновления информации;
    - агрегаты: телеметрия;
    - репозитории: репозиторий телеметрии;
    - сервисы: сервис управления телеметрией.

#### 4. Визуализация контекста системы

Контекст системы представлен [С4 диаграммой контекста](docs/diagrams/context/SmartHome-Context.puml), описывающей взаимодействие монолитного приложения с внешним миром.

### Подзадание 1.2: Архитектура микросервисов

С учётом бизнес-целей, планов по добавлению новых типов устройств необходимо пересмотреть, дополнить и уточнить описание доменов и контекстов:

- Добавить новый домен  **Пользователи** (потребность в нём подразумевается описанием бизнес-логики: "Покупатели могут программировать систему для управления различными модулями в соответствии со своими потребностями.").
- Домен: **Управление отоплением** расширить и переименовать в **Управление умным домом**.
- Поддомен: **Управление отопительными устройствами** расширить и переименовать в **Управление устройствами умного дома**.
- Контекст **Управление устройствами** дополнить элементами для обеспечения регистрации устройств в системе, а также абстрагировать от типа устройства.
- Контекст **Управление телеметрией** также абстрагировать от типа устройства.

После обновления получается следующее описание доменов и границ контекстов:

Домен: **Управление умным домом** (отвечает за функции, связанные с управлением устройствами умного дома)

* Поддомен: **Управление устройствами умного дома** (смысловое ядро)

  * Контекст: **Управление устройствами** (регистрация устройств, обработка команд пользователя)
    - сущности: устройства;
    - объекты-значения: состояние устройства, тип устройства, владелец устройства (user_id);
    - агрегаты: устройства;
    - репозитории: репозиторий устройств;
    - сервисы: сервис управления устройствами.

* Поддомен: **Телеметрия**

  * Контекст: **Сбор телеметрии** (сбор данных с датчиков отопительных систем)
    - сущности: задачи по сбору телеметрии;
    - объекты-значения: устройство (device_id), активность, период опроса;
    - агрегаты: задачи по сбору телеметрии;
    - репозитории: репозиторий задач;
    - сервисы: сервис сбора телеметрии.

  * Контекст: **Управление телеметрией** (хранение и предоставление телеметрических данных пользователям)
    - сущности: телеметрия;
    - объекты-значения: устройство (device_id), информация о состоянии устройства, время последнего обновления информации;
    - агрегаты: телеметрия;
    - репозитории: репозиторий телеметрии;
    - сервисы: сервис управления телеметрией.

Домен: **Пользователи**

* Поддомен: **Управление пользователями**

  * Контекст: **Управление пользователями** (регистрация, аутентификация, авторизация пользователей)
    - сущности: пользователи;
    - объекты-значения: логин, пароль, имя, фамилия, телефон, e-mail;
    - агрегаты: пользователи;
    - репозитории: репозиторий пользователей;
    - сервисы: сервис управления пользователями.


#### 1. Декомпозиция на микросервисы

В соответствии с выделенными доменами и границами контекстов, а также с учётом бизнес-целей выделены следующие микросервисы:

1. Микросервис **Управление устройствами**: установка состояния устройств в соответствии с командами пользователя.
2. Микросервис **Сбор телеметрии**: получение телеметрических данных с устройств, установленных в домах.
3. Микросервис **Управление телеметрией**: предоставление по запросу телеметрических данных пользователям.
4. Микросервис **Управление пользователями**: аутентификация и авторизация пользователей.

При проектировании микросервисной архитектуры использованы следующие паттерны:
- Database per Service — для каждого микросервиса используется своя база данных.
- Event Sourcing — микросервис "Управление телеметрией" хранит историю получения телеметрии для предоставления пользователям данных за выбранный период.
- API Gateway — единая точка входа в микросервисное приложение.

В качестве СУБД для всех сервисов предварительно выбрана PostgreSQL в виду имеющегося у команды опыта работы с ней и для лучшей совместимости с текущей реализацией. Однако, стоит рассмотреть использование альтернативных СУБД: ClickHouse — для хранения телеметрии в привязке ко времени в сервисе "Управление телеметрией", MongoDB (или аналогичные NoSQL решения) — для хранения списка задач по сбору телеметрии в сервисе "Сбор телеметрии".

#### 2. Взаимодействие между узлами архитектуры

* Для маршрутизации запросов к сервисам "Управление пользователями", "Управление устройствами", "Управление телеметрией" используется API Gateway, как единая точка входа (следует предусмотреть механизмы отказоустойчивости — failover).
* Взаимодействие между микросервисами осуществляется через REST API. Необходимости использования очереди сообщений нет. Наоборот, если установить очередь сообщений перед микросервисом "Управление телеметрией", ему потребуется поддерживать сразу 2 интерфейса: REST API (для обработки пользовательских запросов) и интерфейс для взаимодействия с очередью. А использование очереди сообщений для передачи задач в микросервис "Сбор телеметрии" не обеспечивает потребность в отмене поставленных задач.

#### 3. Визуализация архитектуры

* Основные контейнеры системы и их взаимодействие представлены [С4 диаграммой контейнеров](docs/diagrams/container/SmartHome-Container.puml).
* Детализация внутреннего взаимодействия представлена C4 диаграммами компонентов для микросервисов:
  - ["Управление устройствами"](docs/diagrams/component/SmartHome-DeviceManagement-Component.puml),
  - ["Управление телеметрией"](docs/diagrams/component/SmartHome-TelemetryManagement-Component.puml),
  - ["Сбор телеметрии"](docs/diagrams/component/SmartHome-TelemetryCollector-Component.puml).

  Для микросервиса "Управление пользователями" диаграмма не построена, т.к. предполагается использование готовых решений (возможности API Gateway, Keycloak).

* Структура микросервисов "Управление устройствами", "Управление телеметрией", и частично (в части установки/отмены задач) микросервиса "Сбор телеметрии" соответствует типовому Java/Spring приложению. Отдельного рассмотрения заслуживает функционал выполнения задач по сбору телеметрии микросервиса "Сбор телеметрии". Для его представления построена [диаграмма последовательностей](docs/diagrams/code/SmartHome-TaskProcessing-Sequence.puml).

### Подзадание 1.3: ER-диаграмма

#### 1. Идентификация сущностей
В результате тактического проектирования по методологии DDD в предметных областях были выявлены следующие сущности:
* **Пользователь (User)**
* **Устройство (Device)**
* **Телеметрия (Telemetry)**
* **Задача (Task)**

#### 2. Определение атрибутов

* **Пользователь**
  
  Атрибуты:
  - id — уникальный идентификатор пользователя.
  - login — логин для входа в систему.
  - password — пароль для входа в систему.
  - first_name — имя пользователя.
  - last_name — фамилия пользователя.
  - phone — телефон.
  - email — адрес электронной почты.

* **Устройство**

   Атрибуты:
  - id — уникальный идентификатор устройства.
  - user_id — владелец устройства (внешний ключ к таблице Пользователи).
  - status — установленное состояние устройства.
  - device_type — тип устройства.

* **Телеметрия**

  Атрибуты:
  - id — уникальный идентификатор записи о телеметрии.
  - device_id — устройство, предоставившее телеметрию (внешний ключ к таблице Устройства).
  - device_info — информация о текущем состоянии устройства.
  - timestamp — метка времени сбора телеметрии.

* **Задача**

  Атрибуты:
  - id — уникальный идентификатор задачи.
  - device_id — устройство для сбора телеметрии (внешний ключ к таблице Устройства).
  - enabled — активность задачи (true/false).
  - period — минимальный интервал между запусками задачи.
  - last_run_timestamp — метка времени предыдущего запуска задачи.

#### 3. Описание связей

Степени связи между сущностями (один-к-одному, один-ко-многим, многие-ко-многим):
* **Пользователь — Устройство:** один пользователь может иметь доступ к нескольким устройствам, но каждое устройство связано только с одним пользователем.
* **Устройство — Телеметрия:** одно устройство может генерировать множество записей телеметрии, но каждая запись телеметрии относится к одному конкретному устройству.
* **Устройство — Задача:** одно устройство может иметь одну и только одну задачу по сбору телеметрии (активную или остановленную).

#### 4. ER-диаграмма

На основе выявленных сущностей, атрибутов и связей построена [ER-диаграмма](docs/diagrams/ER/SmartHome-ER.puml).

### Подзадание 1.4: Подзадание 1.4: Создание и документирование API

#### 1. Выбор типов API
Для взаимодействия с ключевыми микросервисами "Управление устройствами" и "Управление телеметрией" выбран **REST API**, т.к. эти микросервисы должны предоставлять клиентам немедленные ответы на запросы.
Асинхронность стоит применить при реализации сбора данных телеметрии в микросервисе "Сбор телеметрии", но этот аспект не входит в рамки данного задания.

#### 2. Проектирование API для микросервиса "Управление устройствами"

1. Регистрация нового устройства

* Эндпойнт: /api/devices
* Метод: POST
* Описание: Добавляет новое устройство в систему.

2. Получение информации об устройстве
* Эндпойнт: /api/devices/{id}
* Метод: POST
* Описание: Возвращает информацию о конкретном устройстве по его ID.

3. Управление состоянием устройства (включение/выключение)
* Эндпойнт: /api/devices/{id}/status
* Метод: PUT
* Описание: Позволяет изменить состояние устройства (например, включить/выключить).

4. Отправка команды устройству
* Эндпойнт: POST /api/devices/{id}/commands
* Метод: POST
* Описание: Отправляет команду устройству (например, "установить температуру 22 градуса").

#### 3. Проектирование API для микросервиса "Управление телеметрией"

1. Передача новых данных телеметрии устройства
* Эндпойнт: /api/telemetry
* Метод: POST
* Описание: Передаёт в микросервис телеметрию устройства от микросервиса "Сбор телеметрии" (либо от исходного монолитного приложения).

2. Получение последних данных телеметрии устройства
* Эндпойнт: /api/telemetry/device/{device_id}/latest
* Метод: GET
* Описание: Возвращает пользователю последнее полученное значение телеметрии устройства.

3. Получение исторических данных телеметрии
* Эндпойнт: /api/telemetry/device/{device_id}/history
* Метод: GET
* Описание: Возвращает исторические данные телеметрии устройства за определённый период времени.

#### 4. Описание контрактов взаимодействия

**Управление устройствами**

1. POST /api/devices

* Формат запроса:

  Тело запроса:
  ```json
  {
    "user_id": integer,
    "device_type": "string",
    "status": "string"
  }
  ```

* Формат ответа:

  Тело ответа:
  ```json
  {
    "id": integer,
    "user_id": integer,
    "device_type": "string",
    "status": "string"
  }
  ```

* Коды ответа:
  - 201 Created: Устройство успешно зарегистрировано.
  - 400 Bad Request: Ошибка в данных запроса.

* Примеры:
  - Пример запроса:
  ```http
  POST /api/devices HTTP/1.1
  Content-Type: application/json
  {
    "user_id": 1,
    "device_type": "heating",
    "status": "OFF"
  }
  ```
  - Пример ответа:
  ```http
  HTTP/1.1 201 Created
  Content-Type: application/json
  {
    "id": 1001,
    "user_id": 1,
    "device_type": "heating",
    "status": "OFF"
  }
  ```

2. GET /api/devices/{id}

* Формат запроса:
  
  Параметры пути:
  - id (integer): Идентификатор устройства.

* Формат ответа:

  Тело ответа:
  ```json
  {
    "id": integer,
    "user_id": integer,
    "device_type": "string",
    "status": "string"
  }
  ```

* Коды ответа:
  - 200 OK: Успешно получена информация об устройстве.
  - 404 Not Found: Устройство с указанным идентификатором не найдено.

* Примеры:
  - Пример запроса:
  ```http
  GET /api/devices/1001 HTTP/1.1
  ```
  - Пример ответа:
  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  {
    "id": 1001,
    "user_id": 1,
    "device_type": "heating",
    "status": "OFF"
  }
  ```

3. PUT /api/devices/{id}/status

* Формат запроса:
  
  Параметры пути:
  - id (integer): Идентификатор устройства.
  
  Тело запроса:
  ```json
  {
    "status": "string"
  }
  ```

* Формат ответа:
  
  Тело ответа:
  ```json
  {
    "id": integer,
    "status": "string"
  }
  ```

* Коды ответа:
  - 200 OK: Статус устройства успешно обновлен.
  - 400 Bad Request: Некорректные данные в запросе.
  - 404 Not Found: Устройство с указанным идентификатором не найдено.

* Примеры:

  - Пример запроса:
  ```http
  PUT /api/devices/1001/status HTTP/1.1
  Content-Type: application/json
  {
    "status": "ON"
  }
  ```
  - Пример ответа:
  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  {
    "id": 1001,
    "status": "ON"
  }
  ```

4. POST /api/devices/{id}/commands

* Формат запроса:
  
  Параметры пути:
  - id (integer): Идентификатор устройства.

  Тело запроса:
  ```json
  {
    "command": "string",
    "parameters": {
      "key1": "value1",
      "key2": "value2"
    }
  }
  ```

* Формат ответа:

  Тело ответа:
  ```json
  {
    "id": integer,
    "command": "string",
    "status": "string"
  }
  ```

* Коды ответа:
  - 200 OK: Команда успешно выполнена.
  - 400 Bad Request: Некорректные данные в запросе.
  - 404 Not Found: Устройство с указанным идентификатором не найдено.

* Примеры:

  - Пример запроса:
  ```http
  POST /api/devices/1001/command HTTP/1.1
  Content-Type: application/json
  {
    "command": "setTemperature",
    "parameters": {
      "temperature": 22.5
    }
  }
  ```
  - Пример ответа:
  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  {
    "id": 1001,
    "command": "setTemperature",
    "status": "success"
  }
  ```

**Управление телеметрией**

1. POST /api/telemetry

* Формат запроса:

  Тело запроса:
  ```json
  {
    "device_id": integer,
    "device_info": { ... },
    "timestamp": "string"
  }
  ```

* Формат ответа:
  
  Успешный ответ: Нет содержимого или подтверждающее сообщение.

* Коды ответа:
  - 201 Created: Телеметрия успешно добавлена.
  - 400 Bad Request: Некорректные данные запроса.

* Примеры:

  - Пример запроса:
  ```http
  POST /api/telemetry HTTP/1.1
  Content-Type: application/json
  {
    "device_id": 101,
    "device_info": {
      "status": "ON",
      "temperature": 23.5
    },
    "timestamp": "2024-10-02T14:30:00Z"
  }
  ```

  - Пример ответа:
  ```http
  HTTP/1.1 201 Created
  ```

2. GET /api/telemetry/device/{device_id}/latest

* Формат запроса:

  Параметры пути:
  - device_id (integer): Идентификатор устройства.

* Формат ответа:

  Тело ответа:
  ```json
  {
    "id": integer,
    "device_id": integer,
    "device_info": { ... },
    "timestamp": "string"
  }
  ```

* Коды ответа:
  - 200 OK: Успешно получена текущая телеметрия.
  - 404 Not Found: Телеметрия для указанного устройства не найдена.

* Примеры:

  - Пример запроса:
  ```http
  GET /api/telemetry/device/101/latest HTTP/1.1
  ```

  - Пример ответа:
  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  {
    "id": 5001,
    "device_id": 101,
    "device_info": {
      "status": "ON",
      "temperature": 23.5
    },
    "timestamp": "2024-10-02T14:30:00Z"
  }
  ```

3. GET /api/telemetry/device/{device_id}/history

* Формат запроса:

  Параметры пути:
  - device_id (integer): Идентификатор устройства.

  Параметры запроса:
  - start (string): Начало периода в формате ISO 8601.
  - end (string): Конец периода в формате ISO 8601.

* Формат ответа:

  Тело ответа:
  ```json
  [
    {
      "id": integer,
      "device_id": integer,
      "device_info": { ... },
      "timestamp": "string"
    },
    // ... дополнительные записи телеметрии
  ]
  ```

* Коды ответа:
  - 200 OK: Успешно получена телеметрия за указанный период.
  - 400 Bad Request: Некорректные параметры запроса.
  - 404 Not Found: Телеметрия для указанного устройства не найдена.

* Примеры:

  - Пример запроса:
  ```http
  GET /api/telemetry/device/101/history?start=2024-10-01T00:00:00Z&end=2024-10-02T23:59:59Z HTTP/1.1
  ```

  - Пример ответа:
  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  [
    {
      "id": 5000,
      "device_id": 101,
      "device_info": {
        "status": "OFF",
        "temperature": 21.0
      },
      "timestamp": "2024-10-01T10:15:00Z"
    },
    {
      "id": 5001,
      "device_id": 101,
      "device_info": {
        "status": "ON",
        "temperature": 22.5
      },
      "timestamp": "2024-10-02T14:30:00Z"
    }
  ]
  ```
  
#### 5. Документирование API

API микросервисов описаны в формате OpenAPI:
* **Управление устройствами:** [device-management-api.yml](docs/api/device-management-api.yml)
* **Управление телеметрией:** [telemetry-management-api.yml](docs/api/telemetry-management-api.yml)


## Задание 2: Разработка MVP

### Подзадание 2.1: Новые микросервисы и интеграция с монолитом

В рамках задания реализованы микросервисы:
* **Управление устройствами** — отвечает за регистрацию новых устройств, управление их состоянием (вкл/выкл) и отправку команд.
* **Управление телеметрией** — отвечает за приём, обработку, хранение и предоставление пользователям данных телеметрии от устройств.

#### 1. Выбор языка программирования

Для реализации микросервисов выбран язык Java и фреймврок Spring, т.к. эти инструменты позволяют реализовать надёжное синхронное приложение, взаимодействующее с реляционной БД. Java и Spring поддерживают также и асинхронную функциональность, поэтому их можно применить и для микросервиса "Сбор телеметрии". К тому же, с помощью этих инструментов реализован исходный монолит, что означает наличие соответствующего опыта у команды и упрощает разработку за счёт переиспользования отдельных элементов кодовой базы монолита.

#### 2. Создание проекта

Для разработки микросервисов в текущем репозитории созданы проекты:
* [device-management](device-management)
* [telemetry-management](telemetry-management)

#### 3. Разработка API

[Спецификацию OpenAPI](#5-документирование-api) реализует компонент controller в каждом из микросервисов:
* [DeviceController](device-management/src/main/java/ru/yandex/practicum/smarthome/controller/DeviceController.java)
* [TelemetryController](telemetry-management/src/main/java/ru/yandex/practicum/smarthome/controller/TelemetryController.java)

#### 4. Реализация логики микросервисов

В проектах [device-management](device-management) и [telemetry-management](telemetry-management) добавлен код для обработки запросов к API и выполнения бизнес-логики.
Также в проектах реализована интеграция с СУБД PostgreSQL в соответствии с паттерном Database per Service.
Реализация взаимодействия с брокером сообщений Kafka не требуется.

#### 5. Интеграция с монолитом

Для взаимодействия с монолитом в каждом микросервисе предусмотрен соответствующий REST endpoint:

* **Управление устройствами**
  - **/api/devices/{id}/status** — принимает HTTP PUT-запросы с JSON-телом, содержащим новое состояние устройства ({"status": "ON"} / {"status": "OFF"}). Монолит может вызывать этот endpoint для изменения состояния устройства.
* **Управление телеметрией**
  - **/api/telemetry** — принимает HTTP POST-запросы с JSON-телом, содержащим данные телеметрии. Монолит, получая данные от датчиков, может отправлять их на этот endpoint для сохранения.

#### 6. Развертывание в Minikube:

Для развёртывания микросервисов в Minikube необходимо выполнить следующие команды:

1. Запустить minikube ([инструкция по установке](https://minikube.sigs.k8s.io/docs/start/))

    ```bash
    minikube start
    ```

2. Собрать Docker-образы микросервисов и загрузить в Minikube (если необходимо использовать локальные образы)

  * микросервис **device-management**
    ```bash
    cd device-management
    docker build -t device-management:latest .
    minikube image load device-management:latest
    ```
  * микросервис **telemetry-management**
    ```bash
    cd telemetry-management
    docker build -t telemetry-management:latest .
    minikube image load telemetry-management:latest
    ```
3. Развернуть микросервисы и API Gateway в кластере Kubernetes в Minikube
    ```bash
    cd k8s
    kubectl apply -f device-management
    kubectl apply -f telemetry-management
    kubectl apply -f api-gateway
    ```
4. Получить доступ к микросервисам внутри Minikube через API Gateway
    ```bash
    minikube service nginx-gateway-service
    ```
5. Остановить Minikube для завершения работы
    ```bash
    minikube stop
    ```

#### 7. Дополнительная часть (опционально):
* **Проектирование с помощью Saga.** Паттерн Saga имеет смысл применить при реализации взаимодействия между микросервисами "Управление устройствами" и "Сбор телеметрии" для установки задачи по сбору телеметрии для добавленного устройства (а также для отмены этой задачи при удалении устройства, когда такой функционал будет добавлен). Для реализованных микросервисов "Управление устройствами" и "Управление телеметрией" применение паттерна Saga не требуется.

* **Применение CQRS.** Применимо, но не в рамках текущего спринта. Реализуется путём поднятия дополнительных инстансов микросервисов и настройкой маршрутизации на API Gateway.

* **Расширенное применение 12-факторных приложений.** При реализации микросервисного приложения применены следующие факторы:
  - ✔️**Кодовая база (Codebase).** Кодовая база микросервисов хранится в едином репозитории.
  - ✔️**Зависимости (Dependencies).** Все зависимости микросервисов описаны в манифестах pom.xml.
  - **Конфигурация (Config).** Применимо и реализовано, но для демонстрационных целей настройки доступа к БД оставлены в файлах инструментов развёртывания (Helm charts и манифестах Kubernetes).
  - **Сторонние службы (Backing Services).** Хотя логика взаимодействия с СУБД инкапсулирована в слой Repository микросервисов, заменить PostgreSQL на аналог совсем без изменения кода не получится.
  - ✔️**Сборка, выпуск, запуск (Build, Release, Run).** Пайплайн сборки, выпуска и запуска приложения разделён на отдельные стадии.
  - ✔️**Процессы (Processes).** Каждый микросервис представляет собой отдельный stateless процесс.
  - ✔️ **Порт привязки (Port Binding).** Каждый микросервис может принимать запросы на порт, который можно задать в конфигурации при развёртывании.
  - ✔️ **Конкурентные процессы (Concurrency).** Использование Helm-чартов и API Gateway позволяет легко масштабировать приложение.
  - ✔️ **Утилизируемость (Disposability).** Использование Helm-чартов и API Gateway позволяет легко перезапускать как отдельные микросервисы, так и всё приложение целиком.
  - ✔️ **Среды разработки и эксплуатации (Dev/Prod Parity).** Использование контейнеризации позволяет имитировать производственную среду при разработке и тестировании.
  - ✔️ **Логи (Logs).** Микросервисы приложения пишут свои логи в stdout.
  - ✔️ **Административные процессы (Admin Processes).** Миграции БД (исключая создание исходных таблиц, если они ещё не существуют), задание секретов через переменные окружения запускаются как одноразовые процессы в той же среде, что и основное приложение.

* **Использование Kafka кластера** Спроектированная архитектура системы не требует использования Kafka кластера.

### Подзадание 2.2: Подготовка 3rd party сервисов для связи микросервисов

#### 1. Развертывание Kafka (опционально).
❌ Спроектированная архитектура системы не требует использования Kafka.
#### 2. Настройка Kafka (опционально).
❌ Спроектированная архитектура системы не требует использования Kafka.

#### 3. Развертывание API Gateway.
Приложение использует Nginx в качестве API Gateway. Для его развёртывания используется Helm chart [nginx-gateway](charts/nginx-gateway).

#### 4. Настройка API Gateway.
Маршрутизация запросов от внешних клиентов к соответствующим микросервисам описана в [конфигурации Nginx для Helm chart](charts/nginx-gateway/templates/configmap.yaml).

#### 5. Интеграция микросервисов.
Взаимодействие с микросервисами реализуется посредством REST API.

#### 6. Тестирование.
Для развёртывания микросервисов в Minikube с использованием Helm необходимо выполнить следующие команды:

1. Запустить minikube ([инструкция по установке](https://minikube.sigs.k8s.io/docs/start/))

    ```bash
    minikube start
    ```

2. Собрать Docker-образы микросервисов и загрузить в Minikube (если необходимо использовать локальные образы)

  * микросервис **device-management**
    ```bash
    cd device-management
    docker build -t device-management:latest .
    minikube image load device-management:latest
    ```
  * микросервис **telemetry-management**
    ```bash
    cd telemetry-management
    docker build -t telemetry-management:latest .
    minikube image load telemetry-management:latest
    ```
Это необязательный шаг, т.к. образы микросервисов загружены в репозиторий ghcr.io/ilyaorlov/.

3. Развернуть микросервисы и API Gateway в кластере Kubernetes в Minikube, используя Helm
    ```bash
    cd charts/smart-home-microservices
    helm dependency update
    helm install smart-home-microservices .
    ```
    Helm chart smart-home-microservices позволяет развернуть сразу весь кластер, но также можно развернуть и отдельно каждый микросервис. Например:
    ```bash
    cd charts/device-management
    helm dependency update
    helm install device-management .
    ```

4. Получить доступ к микросервисам внутри Minikube через API Gateway можно двумя способами
    * через minikube (будет предоставлен динамический порт)
    ```bash
    minikube service nginx-gateway
    ```
    * через kubectl
    ```bash
    kubectl --namespace default port-forward svc/nginx-gateway 8080:80
    ```

5. Остановить Minikube для завершения работы
    ```bash
    minikube stop
    ```

## Задание 3: Автоматизация поставки (опционально)

### Подзадание 3.1: Контейнеризация микросервисов

#### 1. Создайте Dockerfile для каждого микросервиса
* [device-management/Dockerfile](device-management/Dockerfile)
* [telemetry-management/Dockerfile](telemetry-management/Dockerfile)

#### 2. Создайте Dockerfile для фронтенда
Реализация фронтенда не предусмотренная временными рамками текущего спринта.

#### 3. Создайте Helm чарты
[Helm чарты](charts) созданы для для всех реализованных микросервисов и API Gateway.

#### 4. Соберите Docker-образы
Docker-образы для всех использованных микросервисов собраны...

#### 5. Загрузите образы в хранилище артефактов:
...и загружены в GitHub Container Registry [ghcr.io/ilyaorlov](https://github.com/IlyaOrlov?tab=packages).

#### 6. Запустите сервисы с помощью Helm
Для развёртывание микросервисов и API Gateway необходимо выполнить следующие команды:
```bash
cd charts/smart-home-microservices
helm dependency update
helm install smart-home-microservices .
```
Helm chart smart-home-microservices позволяет развернуть сразу весь кластер, но также можно развернуть и отдельно каждый микросервис. Например:
```bash
cd charts/device-management
helm dependency update
helm install device-management .
```

#### 7. Протестируйте работу сервисов
Сервисы запускаются без ошибок, взаимодейтсвие с сервисами выполняется должным образом.

### Подзадание 3.2: Настройка CI/CD пайплайнов

#### 1. Создайте Helm чарты для каждого микросервиса и фронтенда
[Helm чарты](charts) созданы для для всех реализованных микросервисов и API Gateway.

#### 2. Создайте CI/CD пайплайн для каждого микросервиса и фронтенда
Шаги пайплайна Github Actions описаны в [ci.yaml](.github/workflows/ci.yaml)

#### 3. Настройте триггеры для запуска пайплайнов
Пайплайны настроены на запуск при каждом пуше кода в репозиторий.

#### 4. Проверьте работу пайплайнов
Пайплайн автоматически запускается и успешно выполняет все этапы (сборка, тестирование, развертывание). 
Выполненные пайплайны можно посмотреть [здесь](https://github.com/IlyaOrlov/architecture-sprint-3/actions).